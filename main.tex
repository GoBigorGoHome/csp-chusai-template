\documentclass{exam-zh}
\usepackage{braket}
\usepackage{listings}
\newcommand{\code}[1]{\texttt{#1}}


%\linespread{0.8} 必须放在 \ttfamily 前面
\lstset{
    numbers=left, 
    basicstyle=\linespread{0.8}\ttfamily
}


% 汉字下加点表示着重。命令： \emph{...}
% https://www.zhihu.com/question/362123706
% \xeCJKsetup {
%     underdot = {
%         symbol = ^^b7,
%         format = \Large
%     }
% }




% 师生两版
\ExamPrintAnswerSet[]{
    solution/show-solution=show-stay,
    paren/show-answer=true,
}

\title{20xx CCF 非专业级别软件能力认证第一轮\\（CSP-S1）提高级 C++语言试题}

\examsetup{
    page = {
        foot-content = CCF CSP-S 20xx 第一轮C++语言试题\\
        第;页，共;页
    },
    font = garamond,
    paren = {
        type = none,
        % show-answer = true %若需要在括号里显示答案，取消注释此行
    },
    fillin = {
        width = 1em,
        type = line, %填空题的空处用下划线标出
        no-answer-type = counter, %空处标上数字序号
        no-answer-counter-label = \circlednumber* %末尾的*不可省略
    },
    solution = {
        % show-solution = show-stay, %若不需要显示解析，注释掉此行
        label-content = 解析,
        show-qed = false
    },
    style = {
        student-version-suffix = _含解析
    }
}

\setmonofont[
  Ligatures=NoCommon, % 取消等宽字体的连字
%   Scale=0.9,
%   Numbers={Lining,Monospaced}
]{texgyrecursor-regular.otf}


\newcommand{\true}{\paren[$\checkmark$]}
\newcommand{\false}{\paren[$\times$]}



\begin{document}
\maketitle

\section{单项选择题（共 15 题，每题 2 分，共计 30 分；每题有且仅有一个正确选项）}

\begin{question}
    在 Linux 系统中，如果你想显示当前工作目录的路径，应该使用哪个命令？~\paren[A]
    \begin{choices}
        \item \code{pwd}
        \item \code{cd}
        \item \code{ls}
        \item \code{echo}
    \end{choices}   
\end{question}

\begin{solution}

\end{solution}

\begin{question}
    假设一个长度为 $n$ 的整数数组中每个元素互不相同，且这个数组是无序的。要找到这个
数组中最大元素的时间复杂度是多少？\paren[A]
\begin{choices}
    \item $O(n)$
    \item $O(\log n)$
    \item $O(n \log n)$
    \item $O(1)$
\end{choices}
\end{question}

\begin{solution}

\end{solution}


\begin{question}
    在 C++中，以下哪个函数调用会造成栈溢出？\paren[C]
\begin{choices}
    \item \code{int foo()\{ return 0;\}}
    \item \code{int bar() \{int x=1; return x;\}}
    \item \code{void baz()\{int a[1000]; baz();\}}
    \item \code{void qux()\{return;\}}
\end{choices}
\end{question}

\begin{solution}

\end{solution}


\begin{question}
    在一场比赛中，有 10 名选手参加，前三名将获得金银铜牌，若不允许并列，且每名选手
    只能获得一枚铜牌，则不同的颁奖方式共有多少种？\paren[B]
\begin{choices}
    \item 120
    \item 720
    \item 504
    \item 1000
\end{choices}
\end{question}

\begin{solution}

\end{solution}

\begin{question}
    下面哪个数据结构最适合实现先进先出（FIFO）的功能？\paren[B]
    \begin{choices}
        \item 栈
        \item 队列
        \item 线性表
        \item 二叉搜索树
    \end{choices}
\end{question}

\begin{solution}
常识。
\end{solution}


\begin{question}
    已知 $f(1) = 1$，且对于 $n \ge 2$ 有 $f(n) = f(n - 1) + f( \lfloor n/2 \rfloor )$ ,则 $f(4)$ 的值为 \paren[B] 。
\begin{choices}
    \item 4
    \item 5
    \item 6
    \item 7
\end{choices}
\end{question}

\begin{solution}

\end{solution}

\begin{question}
    假设一个无向图是欧拉图。以下关于该图的描述中哪一项不一
    定正确？\paren[B 或者 D]
    \begin{choices}
        \item 所有顶点的度数均为偶数
        \item 该图连通
        \item 该图存在一个欧拉回路
        \item 该图的边数是奇数
    \end{choices}

\end{question}

\begin{solution}
    
\end{solution}


\begin{question}
    对数组进行二分查找的过程中，以下哪个条件必须满足？\paren[A]


\begin{choices}
    \item 数组必须是有序的
    \item 数组必须是无序的
    \item 数组长度必须是 2 的幂
    \item 数组中的元素必须是整数
\end{choices}

\end{question}

\begin{solution}
    
\end{solution}


\begin{question}
    考虑一个自然数 $n$ 和一个模数 $m$，你需要计算 $n$ 在模 $m$ 意义下的乘法逆
    元。下列哪种算法最为合适？\paren[B]

\begin{choices}
    \item  暴力依次尝试
    \item  扩展欧几里得算法
    \item  快速幂算法
    \item  线性筛法
\end{choices}
\end{question}


\begin{solution}
    
\end{solution}

\begin{question}
    在设计一个哈希表时，为了减少冲突，需要使用适当的哈希函数和和冲突解决策略。已知某哈希表中有 $n$ 个键值对，表的装载因子为 $\alpha$（$0 < \alpha \le 1$）。在使用开放地址法解决冲突的过程中，最坏情况下查找一个元素的时间复杂度为 \paren[D]
    

    \begin{choices}
        \item  $O(1)$
        \item  $O(\log n)$
        \item  $O (1/(1-\alpha))$
        \item  $O(n)$
    \end{choices}
\end{question}

\begin{solution}

\end{solution}

\begin{question}
    一棵 $h$ 层的完全二叉树最多有少个节点。\paren[A]
    \begin{choices}
        \item $2^{h}-1$
        \item $2^{h+1} - 1$
        \item $2^h$
        \item $2^{h+1}$
    \end{choices}
\end{question}

\begin{solution}
    
\end{solution}



\begin{question}
    设有一个 10 个顶点的完全图，每两个顶点之间都有一条边，有多少个长度为 4 的环？\paren[C]

\begin{choices}
    \item 120
    \item 210
    \item 630
    \item 5040
\end{choices}
\end{question}


\begin{solution}

\end{solution}


\begin{question}
    对于一个整数 $n$，定义 $f(n)$ 为 $n$ 的各个位数之和，问使 $f(f(x))=10$ 的最小自然数 $x$ 是多少？\paren[B]

\begin{choices}
    \item 29
    \item 199
    \item 299
    \item 399
\end{choices}
\end{question}

\begin{solution}
    
\end{solution}

\begin{question}
    设有一个长度为 $n$ 的 01 字符串，其中有 $k$ 个 1，每次操作可以交换相邻两个字符。在最
    坏的情况下将这 $k$ 个 1 移到字符串最右边所需要的交换次数是多少？\paren[C]

\begin{choices}
    \item  $k$
    \item  $k(k-1)/2$
    \item  $(n-k)k$
    \item  $(2n-k-1)k/2$
\end{choices}
\end{question}

\begin{solution}

\end{solution}
    
    
\begin{question}
    如图是一张包含 7 个顶点的有向图。如果要删除一些边，使得从节点 1 到节点 7 没有可
    行路径，且删除的边数最少，请问总共有多少种可行的删除边的集合？\paren[D]
    
    % \includegraphics[width=10cm]{task15.png}

    \begin{choices}
        \item 1
        \item 2
        \item 3
        \item 4
    \end{choices}
\end{question}

\begin{solution}

\end{solution}

\newpage

\section{阅读程序（判断题正确填√，错误填×；除特殊说明外，判断题 1.5 分，选择题 3 分，共计 40 分）}

\subsection*{(1)} %12分

\begin{lstlisting}
#include <iostream>
using namespace std;

const int N = 1000;
int c[N];

int logic(int x, int y) {
    return (x & y) ^ ((x ^ y) | (~x & y));
}
void generate(int a, int b, int *c) {
    for (int i = 0; i < b; i++) {
        c[i] = logic(a, i) % (b + 1);
    }
}
void recursion(int depth, int *arr, int size) {
    if (depth <= 0 || size <= 1)return;
    int pivot = arr[0];
    int i = 0, j = size - 1;
    while (i <= j) {
        while (arr[i] < pivot) i++;
        while (arr[j] > pivot) j--;
        if (i <= j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++; j--;
        }
    }
    recursion(depth - 1, arr, j + 1);
    recursion(depth - 1, arr + i, size - i);
}

int main() {
    int a, b, d;
    cin >> a >> b >> d;
    generate(a, b, c);
    recursion(d, c, b);
    for (int i = 0; i < b; i++) cout << c[i] << " ";
    cout << endl;
}
\end{lstlisting}
     
    \begin{solution}
     
    \end{solution}

    \subsubsection{判断题}
    
    \begin{question}
        当 1000>=d>=b 时，输出的序列是有序的。\true
    \end{question}
    
    \begin{solution}

    \end{solution}

    \begin{question}
        当输入“5 5 1”时，输出为“1 1 5 5 5”。\false
    \end{question}
    
    \begin{solution}
        
    \end{solution}

    \begin{question}
        假设数组 c 长度无限制，该程序所实现的算法的时间复杂度是 $O(b)$ 的。\false
    \end{question}
    
    \begin{solution}
        
    \end{solution}
    
    \subsubsection{单选题}
    
    \begin{question}
        函数 \code{int logic(int x, int y)} 的功能是 \paren[B]。

        \begin{choices}
            \item  按位与
            \item  按位或
            \item  按位异或
            \item  以上都不是
        \end{choices}

    \end{question}
    
    \begin{solution}

    \end{solution}

    \begin{question}[points=4, show-points=true]
        当输入为 \code{10 100 100} 时，输出的第 100 个数是 \paren[C]。

        \begin{choices}
            \item 91
            \item 94
            \item 95
            \item 98
        \end{choices}
    \end{question}

\begin{solution}
    
\end{solution}



\newpage


\subsection*{（2）} %13分

\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std;

const int P = 998244353, N = 1e4 + 10, M = 20;
int n, m;
string s;
int dp[1 << M];

int solve() {
    dp[0] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = (1 << (m - 1)) - 1; j >= 0; j--) {
            int k = (j << 1) | (s[i] - '0');
            if (j != 0 || s[i] == '1')
                dp[k] = (dp[k] + dp[j]) % P;
        }
    }
    int ans = 0;
    for (int i = 0; i < (1 << m); i++) {
        ans = (ans + 1ll * i * dp[i]) % P;
    }
    return ans;
}
int solve2() {
    int ans = 0;
    for (int i = 0; i < (1 << n); i++) {
        int cnt = 0;
        int num = 0;
        for (int j = 0; j < n; j++) {
            if (i & (1 << j)) {
                num = num * 2 + (s[j] - '0');
                cnt++;
            }
        }
        if (cnt <= m) (ans += num) %= P;
    }
    return ans;
}

int main() {
    cin >> n >> m;
    cin >> s;
    if (n <= 20) {
        cout << solve2() << endl;
    }
    cout << solve() << endl;
    return 0;
}
\end{lstlisting}
假设输入的 $s$ 是包含 $n$ 个字符 01 串，完成下面的判断题和单选题。

\begin{solution}

\end{solution}

\subsubsection{判断题}

\begin{question}
    假设数组 dp 长度无限制，函数 solve() 所实现的算法的时间复杂度是 $O(n2^m)$。\true
    \begin{solution}

    \end{solution}
\end{question}

\begin{question}
    输入 \code{11 2 10000000001} 时，程序输出两个数 32 和 23。\true
    \begin{solution}

    \end{solution}
\end{question}



\begin{question}[points=2, show-points=true]
    在 $n \le 10$ 时，solve()的返回值始终小于$4^{10}$。\true
    \begin{solution}

    \end{solution}
\end{question}





\subsubsection{单选题}
\begin{question}
    当 $n=10$ 且 $m=10$ 时，有多少种输入使得两行的结果完全一致？\paren[B]
    \begin{choices}
        \item 1024
        \item 11
        \item 10
        \item 0
    \end{choices}
\end{question}

\begin{solution}

\end{solution}

\begin{question}
    当 $n \le 6$ 时，solve()的最大可能返回值为？\paren[C]

    \begin{choices}
        \item 65
        \item 211
        \item 665
        \item 2059
    \end{choices}
\end{question}


\begin{solution}

\end{solution}


\begin{question}
    若 n=8，m=8，solve 和 solve2 的返回值的最大可能的差值为 \paren[C]。
    \begin{choices}
        \item 1477
        \item 1995
        \item 2059
        \item 2187
    \end{choices}
\end{question}


\begin{solution}
  
\end{solution}


\subsection*{（3）} %15分

\begin{lstlisting}
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 1000000 + 5;
const int P1 = 998244353, P2 = 1000000007;
const int B1 = 2, B2 = 31;
const int K1 = 0, K2 = 13;

typedef long long ll;

int n;
bool p[maxn];
int p1[maxn], p2[maxn];

struct H {
    int h1, h2, l;
    H(bool b = false) {
        h1 = b + K1;
        h2 = b + K2;
        l = 1;
    }
    H operator + (const H &h)const {
        H hh;
        hh.l = l + h.l;
        hh.h1 = (1ll * h1 * p1[h.l] + h.h1) % P1;
        hh.h2 = (1ll * h2 * p2[h.l] + h.h2) % P2;
        return hh;
    }
    bool operator == (const H &h)const {
        return l == h.l && h1 == h.h1 && h2 == h.h2;
    }
    bool operator < (const H &h)const {
        if (l != h.l) return l < h.l;
        else if (h1 != h.h1) return h1 < h.h1;
        else return h2 < h.h2;
    }
} h[maxn];

void init() {
    memset(p, 1, sizeof(p));
    p[0] = p[1] = false;
    p1[0] = p2[0] = 1;
    for (int i = 1; i <= n; i++) {
        p1[i] = (1ll * B1 * p1[i - 1]) % P1;
        p2[i] = (1ll * B2 * p2[i - 1]) % P2;
        if (!p[i])continue;
        for (int j = 2 * i; j <= n; j += i) {
            p[j] = false;
        }
    }
}

int solve() {
    for (int i = n; i; i--) {
        h[i] = H(p[i]);
        if (2 * i + 1 <= n) {
            h[i] = h[2 * i] + h[i] + h[2 * i + 1];
        } else if (2 * i <= n) {
            h[i] = h[2 * i] + h[i];
        }
    }
    cout << h[1].h1 << endl;
    sort(h + 1, h + n + 1);
    int m = unique(h + 1, h + n + 1) - (h + 1);
    return m;
}

int main() {
    cin >> n;
    init();
    cout << solve() << endl;
}
\end{lstlisting}
    
    \begin{solution}

    \end{solution}
    
    \subsubsection*{判断题}
    
    \begin{question}
        假设程序运行前能自动将 \code{maxn} 改为 \code{n + 1}，所实现的算法的时间复杂度是 $O(n
        \log n)$ \true
    \end{question}
    
    \begin{solution}

    \end{solution}

    \begin{question}
        时间开销的瓶颈是 \code{init()} 函数。 \false
    \end{question}
    
    \begin{solution}

    \end{solution}
    \begin{question}
        若修改常数 \code{B1} 或 \code{K1} 的值，该程序可能会输出不同的结果。 \true 
    \end{question}
    
    \begin{solution}

    \end{solution}


    
    \subsubsection*{选择题}
    
    \begin{question}
        30. 在 \code{solve()} 函数中，\code{h[]} 的合并顺序可以看作是：\paren[C]

        \begin{choices}
            \item  二叉树的 BFS 序
            \item  二叉树的先序遍历
            \item  二叉树的中序遍历
            \item  二叉树的后序遍历
        \end{choices}
    \end{question}
    
    \begin{solution}

    \end{solution}
    \begin{question}
        输入“10”，输出的第一行是？\paren[A]

        \begin{choices}
            \item 83
            \item 424
            \item 54
            \item 110101000
        \end{choices}
    \end{question}
    
    \begin{solution}

    \end{solution}


    \begin{question}
        32. (4 分)输入“16”，输出的第二行是？（C）

        \begin{choices}
            \item 7
            \item 9
            \item 10
            \item 12
        \end{choices}
    \end{question}
    
    \begin{solution}

    \end{solution}


\newpage


\section{完善程序（单选题，每小题 3 分，共计 30 分）}

\subsection*{（1）合并序列}

有两个长度为 $N$ 的单调不降序列 $A$ 和 $B$，序列的每个元素都是小于 $10^9$ 的非负整数。在 $A$ 和 $B$ 中各取一个数相加可以得到 $N^2$ 个和，求其中第 $K$ 小的和。上述参数满足 $N \le 10^5$ 和 $1 \le K \le N^2$。

\begin{lstlisting}[escapechar=\%]
#include <iostream>
using namespace std;

const int maxn = 100005;

int n;
long long k;
int a[maxn], b[maxn];

int *upper_bound(int *a, int *an, int ai) {
    int l = 0, r = %\fillin%;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (%\fillin%) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return %\fillin%;
}

long long get_rank(int sum) {
    long long rank = 0;
    for (int i = 0; i < n; i++) {
        rank += upper_bound(b, b + n, sum - a[i]) - b;
    }
    return rank;
}

int solve() {
    int l = 0, r = %\fillin%;
    while (l < r) {
        int mid = ((long long)l + r) >> 1;
        if (%\fillin%) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l;
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++)
        cin >> b[i];
    cout << solve() << endl;
    return 0;
}
\end{lstlisting}

\begin{solution}

\end{solution}


\begin{question}
    \circlednumber{1} 处应填 \paren[A]。
    \begin{choices}
        \item \code{an - a}
        \item \code{an - a - 1}
        \item \code{ai}
        \item \code{ai + 1}
    \end{choices}
\end{question}




\begin{question}
    \circlednumber{2} 处应填 \paren[A]。
    \begin{choices}
        \item \code{a[mid] > ai}
        \item \code{a[mid] >= ai}
        \item \code{a[mid] < ai}
        \item \code{a[mid] <= ai}
    \end{choices}
\end{question}



\begin{question}
    \circlednumber{3} 处应填 \paren[A]。
    \begin{choices}
        \item \code{a + l}
        \item \code{a + l + 1}
        \item \code{a + l - 1}
        \item \code{an - l}
    \end{choices}
\end{question}



\begin{question}
    \circlednumber{4} 处应填 \paren[A]。
    \begin{choices}
        \item \code{a[n - 1] + b[n - 1]}
        \item \code{a[n] + b[n]}
        \item \code{2 * maxn}
        \item \code{maxn}
    \end{choices}
\end{question}


\begin{question}
    \circlednumber{5} 处应填 \paren[A]。
    \begin{choices}
        \item \code{get\_rank(mid) < k}
        \item \code{get\_rank(mid) <= k}
        \item \code{get\_rank(mid) > k}
        \item \code{get\_rank(mid) >= k}
    \end{choices}
\end{question}



% 重置 \fillin 的计数器。
\examsetup{
    fillin = {
        no-answer-counter-index = 1,
    }
}


\subsection*{（2）次短路}
已知有一个 $n$ 个点 $m$ 条边的有向图 $G$，并且给定图中的两个点 $s$ 和 $t$，求次短路（长度严格大于最短路的最短路径）。如果不存在，输出一行“-1”。如果存在，输出两行，第一行表示次短路的长度，第二行表示次短路的一个方案。

\newpage

\begin{lstlisting}[escapechar=\@]
#include <cstdio>
#include <queue>
#include <utility>
#include <cstring>
using namespace std;

const int maxn = 2e5 + 10, maxm = 1e6 + 10, inf = 522133279;

int n, m, s, t;
int head[maxn], nxt[maxm], to[maxm], w[maxm], tot = 1;
int dis[maxn << 1], *dis2;
int pre[maxn << 1], *pre2;
bool vis[maxn << 1];

void add(int a, int b, int c) {
    ++tot;
    nxt[tot] = head[a];
    to[tot] = b;
    w[tot] = c;
    head[a] = tot;
}

bool upd(int a, int b, int d, priority_queue<pair<int, int>> &q) {
    if (d >= dis[b]) return false;
    if (b < n) @\fillin@;
    q.push(@\fillin@);
    dis[b] = d;
    pre[b] = a;
    return true;
}

void solve() {
    priority_queue<pair<int, int>> q;
    q.push(make_pair(0, s));
    memset(dis, @\fillin@, sizeof(dis));
    memset(pre, -1, sizeof(pre));
    dis2 = dis + n;
    pre2 = pre + n;
    dis[s] = 0;
    while (!q.empty()) {
        int aa = q.top().second;q.pop();
        if (vis[aa]) continue;
        vis[aa] = true;
        int a = aa % n;
        for (int e = head[a]; e; e = nxt[e]) {
            int b = to[e], c = w[e];
            if (aa < n) {
                if (!upd(a, b, dis[a] + c, q))
                    @\fillin@
            } else {
                upd(n + a, n + b, dis2[a] + c, q);
            }
        }
    }
}

void out(int a) {
    if (a != s) {
        if (a < n) out(pre[a]);
        else out(@\fillin@);
    }
    printf("%d%c", a % n + 1, " \n"[a == n + t]);
}

int main() {
    scanf("%d%d%d%d", &n, &m,&s,&t);
    s--, t--;
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a - 1, b - 1, c);
    }
    solve();
    if (dis2[t] == inf) puts("-1");
    else {
        printf("%d\n", dis2[t]);
        out(n + t);
    }
}
\end{lstlisting}

\begin{solution}

\end{solution}

\begin{question}
    \circlednumber{1} 处应填 \paren[A]。
    \begin{choices}
        \item \code{udp(pre[b], n + b, dis[b], q)}
        \item \code{upd(a, n + b, d, q)}
        \item \code{upd(pre[b], b, dis[b], q)}
        \item \code{upd(a, b, d, q)}
    \end{choices}
\end{question}


\begin{solution}

\end{solution}


\begin{question}
    \circlednumber{2} 处应填\paren[A]。
    \begin{choices}
\item \code{make\_pair(-d, b)}
\item \code{make\_pair(d, b)}
\item \code{make\_pair(b, d)}
\item \code{make\_pair(-b, d)}
    \end{choices}
\end{question}


\begin{solution}

\end{solution}


\begin{question}
    \circlednumber{3} 处应填\paren[B]。
    \begin{choices}
        \item \code{0xff}
        \item \code{0x1f}
        \item \code{0x3f}
        \item \code{0x7f}
    \end{choices}
\end{question}


\begin{solution}

\end{solution}
\begin{question}
    \circlednumber{4} 处应填 \paren[A]。
    \begin{choices}
        \item \code{upd(a, n + b, dis[a] + c, q)}
        \item \code{upd(n + a, n + b, dis2[a] + c, q)}
        \item \code{upd(n + a, b, dis2[a] + c, q)}
        \item \code{upd(a, b, dis[a] + c, q)}
    \end{choices}
\end{question}

\begin{solution}

\end{solution}

\begin{question}
    \circlednumber{5} 处应填 \paren[A]。
    \begin{choices}
\item \code{pre2[a \% n]}
\item \code{pre2[a]}
\item \code{pre[a \% n]}
\item \code{pre[a \% n] + 1}
    \end{choices}
\end{question}


\begin{solution}

\end{solution}


\end{document}